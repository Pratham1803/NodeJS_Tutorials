** Project Setup:
-> in github we can not push the empty folders:
    - for that, use '.gitkeep' file in empty folders to push that folder.

-> use .gitignor generator to generate ignored files list for github repositories

-> use public folder, to put the users files temporarily on the server in temp folder, than upload those file to third party storage and collect the url and stor in database to access the file.

-> provide all the source code in src folder, to make project more organized

-> when we change some file than we have stop and start the server to see the changes,
    - use nodemon dev depndencies [Those depndencies that we use at development time not in production ], that automatically restart the server.
    - npm i -D nodemon
    - in package.json, scripts, set the "dev" command with "nodemon src/index.js" command

-> in project setup make folders in src folder:
    - files: app.js, index.js, constants.js
    - 1. contollers -> has major functionalities
    - 2. db -> database connection logic
    - 3. middlewares -> to provide validation code, that track the request of users
        - example: if some request require to login of user, than before process the request, check the login status of user.
        - there are more than one middlewares in the middlewares for validating the request 
    - 4. models -> to set all models
    - 5. routes -> set users url (example: /login, /register)
    - 6. utils -> it is utility for provide code files that will use multiple times in project. like, to upload file in profile or in any other place, send multiple types of mails etc.
    
-> install prettier package, so in team it make formatting same for all developers
    - npm i -D prettier
    - create file, ".prettierrc" to provide configuration of formatting.
    - create file ".prettierignore" to ignore the files.

------------------------------------------------------------------------------------------------

** Connect to Mongo Db:
-> Create project in Mongo Db Atlas.
-> in .env file, set port and connection string
-> IMP : Must Wrap all program in Try and catch
-> IMP : Must use async await.
-> Example: const connectionInstance = await mongoose.connect(`${process.env.MONGODB_URL}/${DB_NAME}`);
-> collect host name: connectionInstance.connection.host
-> Two methods to connect to Mongo:
    1. put all code in index.js file
    2. put code in db/index.js and export the connection instance

---------------------------------------------------------------------------------------------------

** Custome API response and Error Handling
-> install packages: cookie-parser and cors
    1. cookie-parser:
        - npm install cookie-parser
    
    2. cors:
        - npm install cors
        - mainly use to connect backend to frontend
        - cross origin resouse sharing
        - app.use(cors())

-> request can come in multiple ways like: form, json, body, form-body.
    - we have to limit the request data because it can crash the server if data is heavy.
    - example: limiting json requests data: app.use(express.json({limit: "16kb"}))        

-> when data is coming from url (query string) we have to read it in our backend:
    - app.use(express.urlencoded({extended: true, limit: "16kb"}));
    - extended: pass objects in objects as query string

-> to store the files in our server's public directory:
    - app.use(express.static("public"));
    - anyone can access those assets

-> set the cookies from the server to client-side:
    - app.use(cookieParser());

-> get method for accepting requests are having 4 fields:
    1. err - error - 
    2. req - request
    3. res - response
    4. next - use in middlewares to give flag to next middleware that it's work is finish now you can do your's.

-> set the stucture of the send error and response to the client-side as in same formate, for that defin files like 'ApiError' and 'ApiResponse' in utils folder that make the same structure for sending responses to the server.